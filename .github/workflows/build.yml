name: CI â€” CMake build

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout this repository
        uses: actions/checkout@v4



      - name: Download and extract gcc-15
        shell: bash
        run: |
          # URL of the .tar.xz to download
          ARCHIVE_URL="https://github.com/Silverlan/test_gcc15/releases/download/2025-11-17/gcc-15.2.0.tar.xz"

          # destination inside the cloned repo (create if needed)
          DEST_DIR="gcc-15"
          mkdir -p "$DEST_DIR"

          # download to a temp file
          curl -L -o /tmp/archive.tar.xz "$ARCHIVE_URL"

          # extract with xz decompression (-J); --strip-components=1 removes top-level folder
          tar -xJf /tmp/archive.tar.xz -C "$DEST_DIR" --strip-components=1

          cd gcc-15
          ls

      - name: Create gcc-15 links
        shell: bash
        run: |
          GCC_ROOT="$PWD/gcc-15"

          # list of logical names clang may look for
          targets=(gcc g++ cc c++ cpp gfortran)
          
          for t in "${targets[@]}"; do
            if [ -e "$GCC_ROOT/bin/$t" ]; then
              echo " -> $t already exists, skipping"
              continue
            fi
          
            # find a candidate with the same prefix (e.g. gcc-15.2.0)
            candidate=$(ls "${t}"* 2>/dev/null | head -n1 || true)
          
            if [ -n "$candidate" ]; then
              # create absolute symlink (safer)
              ln -s "$GCC_ROOT/bin/$candidate" "$GCC_ROOT/bin/$t"
              echo " -> linked $t -> $candidate"
            else
              echo " -> no candidate found for $t"
            fi
          done
          
          # Now ensure common lib directories exist and create expected 'gcc' symlink in lib or lib64 if necessary
          echo "Checking lib directories ..."
          
          for libdir in lib lib64; do
            candidates=( "$GCC_ROOT/$libdir/gcc"* )
            # test for first existing directory that matches (globbing returns pattern if none)
            found=""
            for c in "${candidates[@]}"; do
              if [ -d "$c" ]; then
                found="$c"
                break
              fi
            done
          
            if [ -n "$found" ]; then
              target="$GCC_ROOT/$libdir/gcc"
              if [ ! -e "$target" ]; then
                # symlink to the actual versioned dir
                ln -s "$(basename "$found")" "$target"
                echo " -> created $libdir/gcc -> $(basename "$found")"
              else
                echo " -> $libdir/gcc already exists, skipping"
              fi
            else
              echo " -> no $libdir/gcc* directories found under $GCC_ROOT"
            fi
          done
        
      - name: Set gcc-15 as default
        shell: bash
        run: |
          curDir="$PWD"
          gccDir="$curDir/gcc-15"
          # register main frontends (adjust priority integer if you want different default priority)
          sudo update-alternatives --install /usr/bin/gcc  gcc  $gccDir/bin/gcc-15.2.0  100
          sudo update-alternatives --install /usr/bin/g++  g++  $gccDir/bin/g++-15.2.0  100
          sudo update-alternatives --install /usr/bin/cc   cc   $gccDir/bin/gcc-15.2.0  100
          # sudo update-alternatives --install /usr/bin/cpp  cpp  $gccDir/bin/cpp-15.2.0  100
          # optional: gcov, gfortran, c++ etc. if present:
          sudo update-alternatives --install /usr/bin/gcov gcov $gccDir/bin/gcov-15.2.0 100

          echo "$gccDir/lib64" | sudo tee /etc/ld.so.conf.d/gcc-15.conf
          echo "$gccDir/lib"   | sudo tee -a /etc/ld.so.conf.d/gcc-15.conf

          # refresh cache
          sudo ldconfig




      # Install build tools and cmake (apt-get provides a working version).
      - name: Install build dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      - name: Setup cmake
        uses: jwlawson/actions-setup-cmake@v2

      - name: Build Lua
        shell: bash
        run: |
          git clone https://github.com/Silverlan/LuaJIT.git
          cd LuaJIT
          cd src
          make amalg BUILDMODE=dynamic

      - name: Download and extract tar.xz
        shell: bash
        run: |
          # URL of the .tar.xz to download
          ARCHIVE_URL="https://github.com/Silverlan/clang_prebuilt/releases/download/2025-11-16/linux_x64.tar.xz"

          # destination inside the cloned repo (create if needed)
          DEST_DIR="clang"
          mkdir -p "$DEST_DIR"

          # download to a temp file
          curl -L -o /tmp/archive.tar.xz "$ARCHIVE_URL"

          # extract with xz decompression (-J); --strip-components=1 removes top-level folder
          tar -xJf /tmp/archive.tar.xz -C "$DEST_DIR" --strip-components=1

      - name: Clone external repository
        shell: bash
        run: |
          git clone https://github.com/Silverlan/luabind-deboostified.git luabind

      - name: Copy CMakeLists.txt
        shell: bash
        run: |
          cp CMakeLists.txt luabind/
          cp CMakeLists2.txt luabind/src/CMakeLists.txt
          
      - name: Configure and build with CMake
        shell: bash
        run: |
          curDir="$PWD"
          cd luabind
          mkdir -p build
          export CC="$curDir/bin/clang"
          export CXX="$curDir/bin/clang++"
          cmake -S . -B build -G "Ninja Multi-Config" \
            -DCMAKE_BUILD_TYPE=Release -DLUA_INCLUDE_DIR="$curDir/LuaJIT/src" -DLUA_LIBRARIES="$curDir/LuaJIT/src/libluajit-p.so" \
            -DCMAKE_C_COMPILER="$curDir/clang/bin/clang" -DCMAKE_CXX_COMPILER="$curDir/clang/bin/clang++" \
            -DCMAKE_CXX_STDLIB_MODULES_JSON="$curDir/gcc-15/lib64/libstdc++.modules.json"
          #-DCMAKE_CXX_FLAGS="--gcc-install-dir=$curDir/gcc-15 --stdlib=libstdc++ -L$curDir/gcc-15/lib64"
          cmake --build build -- -j$(nproc)

